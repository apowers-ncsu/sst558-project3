---
title: "Modeling"
author: "Andy Powers"
format: html
---

## Project Introduction

This is the continuation of the project introduced in [EDA.qmd](EDA.qmd).

### Contents

There are six components to this project.

1.  EDA - quarto file with EDA *(this file)*

2.  Modeling - quarto file to select the best model using `tidymodels`

3.  API - R file fitting the model and defining API structure

4.  Dockerfile - for building the Docker image

5.  .tar - Docker image

6.  Demo - video showing me demonstrating my Docker container

## Modeling

This Quarto file continues into the Modeling step. We need to make a training/test split (70/30) and include a seed. We will predict the diabetes response variable using different models via `tidymodels`, evaluating with 5CV log-loss as metric. I'm not stratifying the split.

### Data split

I'm using a 70% split for a training subset of the data. Here, I'm also specifying the seed as 1.

```{r}
set.seed(1)

split <- initial_split(data, prop = 0.7)
train <- training(split)
test <- testing(split)
train_5cv <- vfold_cv(train, 5)

#adding another copy for a first, smaller pass to find interesting variables for full modeling
first_split <- initial_split(sample_n(data, 20000), prop = 0.7)
first_train <- training(first_split)
first_test <- testing(first_split)
first_train_5cv <- vfold_cv(first_train, 5)
```

### Classification Tree

The first model type used here is a classification tree. As the tree builds, at each level the best (per our metric) predictor and its value are used to separate into two subsequent branches of the tree: is x > 0.5? Yes - path A; No - path B. Then recursively the same occurs at each subsequent branch, up to some number of levels of the tree. This is not an optimal solution, as it can be influenced significantly by the data grabbed in the training set, but it is fairly intuitive to interpret as a series of sequential yes/no decisions that land either on a success or failure (most prevalent for training data) at the bottom of the tree.

We will tune the number of levels and any other tunable parameters, using 5Fold CV as mentioned earlier.

#### Recipe definition

Not much needs to happen here, aside from creating numerous dummy variables. I will also normalize my few numeric variables. I will start first with a 21 predictor set for a subset (20000), to attempt to see the predictive strength of each input. Then, I'll choose some smaller number of the more interesting variables to use for the rest of the work (including a re-evaluation of this model).

```{r}
#first, adjusting
first_recipe <- recipe(Diabetes_binary ~ ., data = first_train) |>
  
  #normalize numerics
  step_normalize(
    all_numeric(),
    -all_outcomes()
    ) |>
  
  #dummy vars for categorical items
  step_dummy(
    all_factor_predictors()
    )
```

#### Model tuning

Now, defining the model characteristics, workflow, and tuning.

```{r}
#model
first_model_classtree <- 
  decision_tree(
    tree_depth = tune(),
    min_n = tune(),
    cost_complexity = tune()
    ) |>
  set_engine("rpart")|>#,importance="impurity") |>
  set_mode("classification")

#workflow
first_workflow_classtree <- workflow() |>
  add_recipe(first_recipe) |>
  add_model(first_model_classtree)

#grid config
first_grid_classtree <- grid_regular(
  cost_complexity(),
  tree_depth(),
  min_n(),
  levels = c(3, 3, 3)
  )

#tuning setup
temp <- first_workflow_classtree |> 
  tune_grid(
    resamples = first_train_5cv,
    grid = first_grid_classtree,
    metrics = metric_set(mn_log_loss)
    )

temp |> 
  collect_metrics()
```

Continuing with tuning accordingly for this first, small pass, and then displaying importance for each predictor.

```{r}
first_tune_classtree <- temp |>
  select_best(metric = "mn_log_loss")

first_workflow_classtree <- first_workflow_classtree |>
  finalize_workflow(first_tune_classtree)
first_fit_classtree <- first_workflow_classtree |>
  fit(first_train)

temp2 <- extract_fit_engine(first_fit_classtree)$variable.importance
tibble(term=names(temp2),value=temp2) |>
  arrange(value) |>
  mutate(term = factor(term, levels = term)) |>
  ggplot(aes(x = term, y = value)) +
  geom_bar(stat ="identity") +
  coord_flip()
```

Wow, it is so frustrating to get all the syntax just right to work, in practice! At least this chart is clear in direction! I want to study the more important variables, such as those in the top 10 here. I'll choose some of the top and one or two low-importance items that I had expected to relate strongly. These need renaming, too.

```{r}
#overwriting recipe with reference to full scale training dataset
recipe <- recipe(Diabetes_binary ~ ., data = train) |>
  
  #normalize numerics
  step_normalize(
    all_numeric(),
    -all_outcomes()
    ) |>
  
  #dummy vars for categorical items
  step_dummy(
    all_factor_predictors()
  ) |>

  #stripping out many columns
  step_select(
    Diabetes_binary,
    high_bp = HighBP_high.blood.pressure,
    bmi = BMI,
    difficulty_walking = DiffWalk_walking.difficulty,
    high_cholesterol = HighChol_high.cholesterol,
    heart_problems = HeartDiseaseorAttack_heart.problems.CHD.MI,
    vegetables = Veggies_vegetables,
    health_poor = GenHlth_poor,
    health_fair = GenHlth_fair,
    health_good = GenHlth_good,
    health_very_good = GenHlth_very.good,
    physical_health_problems = PhysHlth,
    mental_health_problems = MentHlth,
    physical_activity = PhysActivity_physical.activity,
    smoker = Smoker_smoker,
    male = Sex_male
  )

#checking results look ok
head(recipe|>prep()|>bake(head(train)))
```

Looks ok! Now, let's build the proper classification tree model with 5Fold CV on our proper training samples.

#### Full model tuning

```{r}
#model
model_classtree <- 
  decision_tree(
    tree_depth = tune(),
    min_n = tune(),
    cost_complexity = tune()
    ) |>
  set_engine("rpart") |>
  set_mode("classification")

#workflow
workflow_classtree <- workflow() |>
  add_recipe(recipe) |>
  add_model(model_classtree)

#grid config
grid_classtree <- grid_regular(
  cost_complexity(),
  tree_depth(),
  min_n(),
  levels = c(3, 3, 3)
  )

#tuning setup
temp <- workflow_classtree |> 
  tune_grid(
    resamples = train_5cv,
    grid = grid_classtree,
    metrics = metric_set(mn_log_loss)
    )

tune_classtree <- temp |> 
  select_best(metric = "mn_log_loss")

workflow_classtree <- workflow_classtree |>
  finalize_workflow(tune_classtree)
fit_classtree <- workflow_classtree |>
  fit(train)

temp2 <- extract_fit_engine(fit_classtree)$variable.importance
tibble(term=names(temp2),value=temp2) |>
  arrange(value) |>
  mutate(term = factor(term, levels = term)) |>
  ggplot(aes(x = term, y = value)) +
  geom_bar(stat ="identity") +
  coord_flip()
```

